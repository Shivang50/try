import os
import re
import sys


# -------------------------------
# FILE READ / WRITE
# -------------------------------

def read_file(path):
    with open(path, "r") as f:
        return f.read()


def write_file(path, content):
    with open(path, "w") as f:
        f.write(content)


# -------------------------------
# BLOCK EXTRACTION
# -------------------------------

def extract_block(text, start_index):
    brace_start = text.find("{", start_index)
    if brace_start == -1:
        return None, start_index

    depth = 1
    i = brace_start + 1
    n = len(text)

    while i < n and depth > 0:
        if text[i] == "{":
            depth += 1
        elif text[i] == "}":
            depth -= 1
        i += 1

    return text[start_index:i], i


# -------------------------------
# MODE EXTRACTION
# -------------------------------

def get_mode(block_text):
    match = re.search(
        r'mode\s*\(\s*modes\s*,\s*\\?\s*"([^"]+)"',
        block_text,
        re.DOTALL
    )
    if match:
        return match.group(1).strip()
    return None


# -------------------------------
# FILTERING LOGIC
# -------------------------------

def filter_by_mode(text, required_mode):
    n = len(text)
    i = 0
    output = []

    while i < n:

        if text.startswith("internal_power", i) or text.startswith("timing", i):

            block, end_i = extract_block(text, i)

            if block:
                mode = get_mode(block)

                if mode is None or mode == required_mode:
                    output.append(block)

                i = end_i
                continue

        output.append(text[i])
        i += 1

    return "".join(output)


# -------------------------------
# REMOVE MODE DEFINITIONS
# -------------------------------

def remove_mode_definitions(text):

    n = len(text)
    i = 0
    output = []

    while i < n:

        if text.startswith("mode_definition", i):
            block, end_i = extract_block(text, i)
            if block:
                i = end_i
                continue

        output.append(text[i])
        i += 1

    cleaned_text = "".join(output)

    cleaned_text = re.sub(
        r'mode\s*\(\s*modes\s*,\s*\\?\s*"[^"]+"\s*\)\s*;',
        '',
        cleaned_text,
        flags=re.DOTALL
    )

    return cleaned_text


# -------------------------------
# PROCESS ONE FILE
# -------------------------------

def generate_all_modes(input_file):

    print(f"\nProcessing: {input_file}")

    content = read_file(input_file)
    modes = ["MODE_R1K", "MODE_R2P2K", "MODE_R4K"]
    base_name = os.path.splitext(os.path.basename(input_file))[0]

    for mode in modes:

        os.makedirs(mode, exist_ok=True)

        filtered = filter_by_mode(content, mode)
        cleaned = remove_mode_definitions(filtered)

        output_file = os.path.join(mode, f"{base_name}_{mode}.lib")

        write_file(output_file, cleaned)

        print(f"Generated: {output_file}")


# -------------------------------
# MAIN EXECUTION LOGIC
# -------------------------------

def main():

    print("Select input type:")
    print("1 → Single .lib file")
    print("2 → Directory containing .lib files")

    choice = input("Enter 1 or 2: ").strip()

    if choice == "1":
        file_path = input("Enter full path of .lib file: ").strip()

        if not os.path.isfile(file_path):
            print("Invalid file path.")
            return

        generate_all_modes(file_path)

    elif choice == "2":
        dir_path = input("Enter directory path: ").strip()

        if not os.path.isdir(dir_path):
            print("Invalid directory path.")
            return

        lib_files = [f for f in os.listdir(dir_path) if f.endswith(".lib")]

        if not lib_files:
            print("No .lib files found in directory.")
            return

        for file_name in lib_files:
            full_path = os.path.join(dir_path, file_name)
            generate_all_modes(full_path)

    else:
        print("Invalid choice. Please enter 1 or 2.")


if __name__ == "__main__":
    main()
